
	public class Clock
	{

		// milliseconds per cycle
		private float millisPerCycle;

		// last update time
		private long lastUpdate;

		// number of elasped cycles
		private int elapsedCycles;

		// time between cycles
		private float excessCycles;

		// if clock is paused
		private boolean isPaused;

		// creates a new clock
		public Clock(float cyclesPerSecond)
		{
			setCyclesPerSecond(cyclesPerSecond);
			reset();
		}

		// sets cycles per second
		public void setCyclesPerSecond(float cyclesPerSecond)
		{
			this.millisPerCycle = (1.0f / cyclesPerSecond) * 1000;
		}

		// resets the clock stats
		public void reset()
		{
			this.elapsedCycles = 0;
			this.excessCycles = 0.0f;
			this.lastUpdate = getCurrentTime();
			this.isPaused = false;
		}

		// Updates the clock stats
		public void update()
		{
			// Get the current time and calculate the time.
			long currUpdate = getCurrentTime();
			float delta = (float) (currUpdate - lastUpdate) + excessCycles;

			// Update the number of elapsed and excess ticks if not paused
			if (!isPaused)
			{
				this.elapsedCycles += (int) Math.floor(delta / millisPerCycle);
				this.excessCycles = delta % millisPerCycle;
			}

			// Set the last update time for the next update cycle
			this.lastUpdate = currUpdate;
		}

		// pauses or unpauses clock
		public void setPaused(boolean paused)
		{
			this.isPaused = paused;
		}

		// checks to see if clock is paused
		public boolean isPaused()
		{
			return isPaused;
		}

		// checks to see if a cycle has elapsed
		public boolean hasElapsedCycle()
		{
			if (elapsedCycles > 0)
			{
				this.elapsedCycles--;
				return true;
			}
			return false;
		}

		// checks to see if cycles has elasped but will not decrement if lower than
		// 0
		public boolean peekElapsedCycle()
		{
			return (elapsedCycles > 0);
		}

		// calculates time
		private static final long getCurrentTime()
		{
			return (System.nanoTime() / 1000000L);
		}

	}

