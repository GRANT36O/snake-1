i
import java.awt.Point;
import java.util.LinkedList;

public class Snake extends GameBoard
{

	/*
	 * The GameBoard instance.
	 */
	private GameBoard board;

	/*
	 * Create the list that contains the points of the snake.
	 */
	private LinkedList<Point> points;

	/*
	 * Creates a new Snake instance.
	 * 
	 * @param board The GameBoard instance.
	 */
	public Snake(GameBoard board)
	{
		this.board = board;
		this.points = new LinkedList<Point>();
		resetSnake();
	}

	public static enum Direction
	{

		/*
		 * Snake is moving up.
		 */
		UP,

		/*
		 * Snake is moving down.
		 */
		DOWN,

		/*
		 * Snake is moving left.
		 */
		LEFT,

		/*
		 * Snake is moving right.
		 */
		RIGHT,

		/*
		 * Snake is stationary.
		 */
		NONE

	}

	/*
	 * The current direction that the snake is moving.
	 */
	private Direction currentDirection;

	private Direction temporaryDirection;

	public void resetSnake()
	{
		this.currentDirection = Direction.NONE;
		this.temporaryDirection = Direction.NONE;

		Point head = new Point(GameBoard.MAP_SIZE / 2, GameBoard.MAP_SIZE / 2);
		points.clear();
		points.add(head);
		board.setTile(head.x, head.y, TileType.SNAKE);
	}

	public TileType updateSnake()
	{

		/*
		 * Polls the snake's direction from the keyboard input, explained later.
		 */
		this.currentDirection = temporaryDirection;

		/*
		 * Gets the location of the head of the snake.
		 */
		Point head = points.getFirst();

		/*
		 * Gets the current direction of the snake, and returns false if the
		 * direction leads us into a wall. Otherwise, it pushes a new point onto
		 * the first position of the list (the head) in the new position of the
		 * head.
		 */
		switch (currentDirection)
		{

		case UP:
			if (head.y <= 0)
			{
				return null;
			}
			points.push(new Point(head.x, head.y - 1));
			break;

		case DOWN:
			if (head.y >= GameBoard.MAP_SIZE - 1)
			{
				return null;
			}
			points.push(new Point(head.x, head.y + 1));
			break;

		case LEFT:
			if (head.x <= 0)
			{
				return null;
			}
			points.push(new Point(head.x - 1, head.y));
			break;

		case RIGHT:
			if (head.x >= GameBoard.MAP_SIZE - 1)
			{
				return null;
			}
			points.push(new Point(head.x + 1, head.y));
			break;

		case NONE:
			return TileType.EMPTY;
		}

		/*
		 * Updates the head variable with the position of the new head.
		 */
		head = points.getFirst();

		/*
		 * Gets the type of tile that was at the head location before we
		 * updated. If the tile type was not a fruit, we remove the last point
		 * from the snake and update the board to reflect this.
		 */
		TileType oldType = board.getTile(head.x, head.y);
		if (!oldType.equals(TileType.FRUIT))
		{
			Point last = (Point) points.removeLast();
			board.setTile(last.x, last.y, TileType.EMPTY);
			oldType = board.getTile(head.x, head.y);
		}

		/*
		 * Set the tile at the head location to a snake tile. /
		 * board.setTile(head.x, head.y, TileType.SNAKE);
		 * 
		 * /* Return the tile type.
		 */
		return oldType;
	}

}
